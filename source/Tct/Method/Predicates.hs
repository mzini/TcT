{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveDataTypeable #-}

--------------------------------------------------------------------------------
-- | 
-- Module      :  Tct.Method.Predicates
-- Copyright   :  (c) Martin Avanzini <martin.avanzini@uibk.ac.at>, 
--                Georg Moser <georg.moser@uibk.ac.at>, 
--                Andreas Schnabl <andreas.schnabl@uibk.ac.at>,
-- License     :  LGPL (see COPYING)
--
-- Maintainer  :  Martin Avanzini <martin.avanzini@uibk.ac.at>
-- Stability   :  unstable
-- Portability :  unportable      
-- 
-- This module defines various predicate processors, i.e., processors
-- that return either @Yes(?,?)@ or @No@.
--------------------------------------------------------------------------------   

module Tct.Method.Predicates 
       (
         PredicateProof
       , WhichTrs(..)   
       , Predicate
       , predicateProcessors
       , trsPredicateProcessor
       , problemPredicateProcessor
       -- * Instances
       , isCollapsing
       , isConstructor
       , isDuplicating
       , isLeftLinear
       , isRightLinear
       , isOverlay
       , isOrthogonal
       , isGround
       , isWellFormed
       , isFull
       , isInnermost
       , isOutermost
       , isRCProblem      
       , isDCProblem
       , isContextSensitive
         -- ** Lifting of functions to predicate processors.
       , trsPredicate
       , problemPredicate
         -- * Processors
       , isCollapsingProcessor
       , isConstructorProcessor
       , isDuplicatingProcessor
       , isLeftLinearProcessor
       , isRightLinearProcessor
       , isOrthogonalProcessor
       , isOverlayProcessor
       , isGroundProcessor
       , isWellFormedProcessor
       , isFullProcessor
       , isInnermostProcessor
       , isOutermostProcessor
       , isRCProblemProcessor
       , isDCProblemProcessor
       , isContextSensitiveProcessor
       )
       where

import Text.PrettyPrint.HughesPJ
import Data.Typeable 
import qualified Termlib.Trs as Trs
import Termlib.Trs (Trs)
import Termlib.Problem (strictTrs, weakTrs, Strategy (..), Problem (..), StartTerms(..), startTerms)
import qualified Tct.Processor.Args as A
import Tct.Processor.Args
import Tct.Processor.Args.Instances (EnumOf (..))
import qualified Tct.Processor.Standard as S
import qualified Tct.Processor as P


-- | Determines which components of a problem should be checked.
data WhichTrs = Strict -- ^ Check predicate on strict components.
              | Weak  -- ^ Check predicate on weak components.
              | Both  -- ^ Check predicate on weak and strict components.
              | Union -- ^ Check predicate on the union of strict and strict components.
              deriving (Typeable, Eq, Ord, Enum, Bounded)

instance Show WhichTrs where
    show Strict = "strict"
    show Weak = "weak"
    show Both = "both"
    show Union = "union"


-- | The predicate processor.
data Predicate = TrsPredicate String (Trs -> Bool)
               | ProblemPredicate String (Problem -> Bool)
                 
-- | Proof generated by predicate processor.                 
data PredicateProof = PredicateProof Predicate P.Answer

instance P.ComplexityProof PredicateProof where
    answer (PredicateProof _ a) = a
    pprintProof (PredicateProof (TrsPredicate n _) a) _ = text "The input is" <+> ans <+> text n <> text "."
        where ans | P.succeeded a = empty
                  | otherwise     = text "NOT"
    pprintProof (PredicateProof (ProblemPredicate n _) a) _ = text "The input problem is" <+> ans <+> text n <> text "."
        where ans | P.succeeded a = empty
                  | otherwise     = text "NOT"

instance S.Processor Predicate where
    type ArgumentsOf Predicate = Arg (EnumOf WhichTrs)
    type ProofOf Predicate = PredicateProof
    name (TrsPredicate n _) = n
    name (ProblemPredicate n _) = n
    solve inst prob = return $ PredicateProof proc ans
        where proc = S.processor inst
              holds = case proc of 
                        TrsPredicate _ p -> 
                            case S.processorArgs inst of 
                              Strict -> p $ strictTrs prob
                              Weak   -> p $ weakTrs prob
                              Union  -> p $ strictTrs prob `Trs.union` weakTrs prob
                              Both   -> p (strictTrs prob) &&  p (weakTrs prob)
                        ProblemPredicate _ p -> p prob                              
              ans | holds     = P.yesAnswer
                  | otherwise = P.NoAnswer
    arguments _ = opt { A.name = "on"
                      , A.description = unlines [ "Chooses the TRS from the problem on which the predicate is applied (only applies to predicates on TRSs)."]
                      , A.defaultValue = Strict}


trsPredicateProcessor :: String -> (Trs -> Bool) -> S.StdProcessor Predicate     
trsPredicateProcessor s p = S.StdProcessor $ TrsPredicate s p
problemPredicateProcessor :: String -> (Problem -> Bool) -> S.StdProcessor Predicate     
problemPredicateProcessor s p = S.StdProcessor $ ProblemPredicate s p


isDuplicatingProcessor :: S.StdProcessor Predicate
isDuplicatingProcessor = trsPredicateProcessor "duplicating" Trs.isDuplicating
isConstructorProcessor :: S.StdProcessor Predicate
isConstructorProcessor = trsPredicateProcessor "constructor" Trs.isConstructor
isCollapsingProcessor :: S.StdProcessor Predicate
isCollapsingProcessor = trsPredicateProcessor "collapsing" Trs.isCollapsing
isGroundProcessor :: S.StdProcessor Predicate
isGroundProcessor = trsPredicateProcessor "ground" Trs.isGround
isLeftLinearProcessor :: S.StdProcessor Predicate
isLeftLinearProcessor = trsPredicateProcessor "leftlinear" Trs.isLeftLinear
isRightLinearProcessor :: S.StdProcessor Predicate
isRightLinearProcessor = trsPredicateProcessor "rightlinear" Trs.isRightLinear
isWellFormedProcessor :: S.StdProcessor Predicate
isWellFormedProcessor = trsPredicateProcessor "wellformed" Trs.wellFormed
isOverlayProcessor :: S.StdProcessor Predicate
isOverlayProcessor = trsPredicateProcessor "overlay" Trs.isOverlay
isOrthogonalProcessor :: S.StdProcessor Predicate
isOrthogonalProcessor = trsPredicateProcessor "orthogonal" Trs.isOrthogonal

isStrat :: String -> (Strategy -> Bool) -> S.StdProcessor Predicate
isStrat n check = problemPredicateProcessor n (\ prob -> check $ strategy prob)
isStartTerms :: String -> (StartTerms -> Bool) -> S.StdProcessor Predicate
isStartTerms n check = problemPredicateProcessor n (\ prob -> check $ startTerms prob)

isOutermostProcessor :: S.StdProcessor Predicate
isOutermostProcessor = isStrat "outermost" ((==) Outermost)
isInnermostProcessor :: S.StdProcessor Predicate
isInnermostProcessor = isStrat "innermost" ((==) Innermost)
isFullProcessor :: S.StdProcessor Predicate
isFullProcessor = isStrat "fullstrategy" ((==) Full)
isContextSensitiveProcessor :: S.StdProcessor Predicate
isContextSensitiveProcessor = isStrat "contextsensitive" (\ s -> case s of ContextSensitive _ -> True; _ -> False)
isDCProblemProcessor :: S.StdProcessor Predicate
isDCProblemProcessor = isStartTerms "DC problem" (\ t -> case t of TermAlgebra{} -> True; _ -> False)
isRCProblemProcessor :: S.StdProcessor Predicate
isRCProblemProcessor = isStartTerms "RC problem" (\ t -> case t of BasicTerms{} -> True; _ -> False)

-- | Collects all predicate processors.
predicateProcessors :: [S.StdProcessor Predicate]
predicateProcessors = [ isDuplicatingProcessor
                      , isConstructorProcessor
                      , isCollapsingProcessor
                      , isGroundProcessor
                      , isLeftLinearProcessor
                      , isRightLinearProcessor
                      , isOrthogonalProcessor
                      , isOverlayProcessor
                      , isWellFormedProcessor
                      , isOutermostProcessor
                      , isFullProcessor
                      , isInnermostProcessor
                      , isContextSensitiveProcessor ]


trsPredicate :: String -> (Trs -> Bool) -> WhichTrs -> S.ProcessorInstance Predicate
trsPredicate s p a = (S.StdProcessor $ TrsPredicate s p) `S.withArgs` a

problemPredicate :: String -> (Problem -> Bool) -> S.ProcessorInstance Predicate
problemPredicate s p = (S.StdProcessor $ ProblemPredicate s p) `S.withArgs` Union


isDuplicating :: WhichTrs -> S.ProcessorInstance Predicate
isDuplicating a = isDuplicatingProcessor `S.withArgs` a
isCollapsing :: WhichTrs -> S.ProcessorInstance Predicate
isCollapsing a = isCollapsingProcessor `S.withArgs` a
isConstructor :: WhichTrs -> S.ProcessorInstance Predicate
isConstructor a = isConstructorProcessor `S.withArgs` a
isGround :: WhichTrs -> S.ProcessorInstance Predicate
isGround a = isGroundProcessor `S.withArgs` a
isLeftLinear :: WhichTrs -> S.ProcessorInstance Predicate
isLeftLinear a = isLeftLinearProcessor `S.withArgs` a
isRightLinear :: WhichTrs -> S.ProcessorInstance Predicate
isRightLinear a = isRightLinearProcessor `S.withArgs` a
isWellFormed :: WhichTrs -> S.ProcessorInstance Predicate
isWellFormed a = isWellFormedProcessor `S.withArgs` a
isOrthogonal :: WhichTrs -> S.ProcessorInstance Predicate
isOrthogonal a = isOrthogonalProcessor `S.withArgs` a
isOverlay :: WhichTrs -> S.ProcessorInstance Predicate
isOverlay a = isOverlayProcessor `S.withArgs` a
isOutermost :: S.ProcessorInstance Predicate
isOutermost = isOutermostProcessor `S.withArgs` Union
isInnermost :: S.ProcessorInstance Predicate
isInnermost = isInnermostProcessor `S.withArgs` Union
isFull :: S.ProcessorInstance Predicate
isFull = isFullProcessor `S.withArgs` Union
isContextSensitive :: S.ProcessorInstance Predicate
isContextSensitive = isContextSensitiveProcessor `S.withArgs` Union

isDCProblem :: S.ProcessorInstance Predicate
isDCProblem = isDCProblemProcessor `S.withArgs` Union
isRCProblem :: S.ProcessorInstance Predicate
isRCProblem = isRCProblemProcessor `S.withArgs` Union

